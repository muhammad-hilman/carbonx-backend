package com.ecapybara.carbonx.controller;

import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Direction;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;

import com.ecapybara.carbonx.config.AppLogger;
import com.ecapybara.carbonx.model.DigitalProductPassport;
import com.ecapybara.carbonx.model.Product;
import com.ecapybara.carbonx.repository.ProductRepository;
import com.ecapybara.carbonx.service.DocumentService;
import com.ecapybara.carbonx.service.GraphService;
import com.ecapybara.carbonx.service.LCAService;

import reactor.core.publisher.Mono;


@RestController
@RequestMapping("/api/products")
public class ProductController {
  
  @Autowired
  private DocumentService documentService;
  @Autowired
  private GraphService graphService;
  @Autowired
  private ProductRepository productRepository;

  private static final Logger log = LoggerFactory.getLogger(AppLogger.class);
  final Sort sort = Sort.by(Direction.DESC, "id");

  @GetMapping
  public Iterable<Product> getProducts(@RequestParam(name = "productName", required = false) String productName,@RequestParam(name = "productNature", required = false) String productNature) {
    if (productName != null && !productName.isEmpty() && productNature!=null && !productNature.isEmpty()) {
      return productRepository.findByNameAndProductNature(sort, productName, productNature);
    }
    else if (productName != null && !productName.isEmpty()) {
      return productRepository.findByName(sort, productName);
    }
    else if (productNature != null && !productNature.isEmpty()) {
      return productRepository.findByProductNature(sort, productNature);
    }
    else {
      return productRepository.findAll();
    }
  }

  @PostMapping(consumes = MediaType.APPLICATION_JSON_VALUE)
  @ResponseStatus(value = HttpStatus.CREATED)
  public List<Product> createProducts(@RequestBody List<Product> productsList) {
    
    for (Product product : productsList) {
      System.out.println("----- New product created:");
      System.out.println(product.toString());

      productRepository.save(product);
      product = productRepository.findByNameAndProductNature(sort, product.getName(), product.getType()).get(0);
      System.out.println("Created product saved into product database:");
      System.out.println(product.toString());
    }

    return productsList;
  }

  @PutMapping
  public List<Product> editProducts(@RequestBody List<Product> revisedProducts) {
    for (Product productRevision : revisedProducts) {
      Product product = editProduct(productRevision.getId(), productRevision);
      productRevision = product; //replace the list element with the new entity from database
    }
    return revisedProducts;
  }

  @GetMapping("/{id}")
  public Mono<Product> getProduct(@PathVariable String id) {
    return documentService.getDocuments("products", id)
            .bodyToMono(Product.class)
            .doOnNext(body -> log.info("API Response:\n{}", body));
  }

  @PutMapping("/{id}")
  public Product editProduct(@PathVariable String id, @RequestBody Product revisedProduct) {
    Product product = productRepository.findById(id).orElse(null);
    
    if (product != null) {
      product.setName(revisedProduct.getName());
      product.setType(revisedProduct.getType());
      product.setProductOrigin(revisedProduct.getProductOrigin());
      product.setFunctionalProperties(revisedProduct.getFunctionalProperties());
      product.setDPP(revisedProduct.getDPP());
      product.setUserId(revisedProduct.getUserId());
      product.setUploadedFile(revisedProduct.getUploadedFile());
      productRepository.save(product);
    }
    
    return productRepository.findById(id).orElse(null);
  }

  // Proper document deletion require the use of ArangoDB's Graph API since AQL does not cleanly delete hanging edges. Trust me, I've tried
  @DeleteMapping("/{id}")
  public Mono<Boolean> removeProduct(@PathVariable String id) {
    return graphService.deleteDocuments("products", id);
  }

  @GetMapping("/{id}/calculate")
  public Mono<?> calculateProduct(@PathVariable String id) {
    Product product = productRepository.findById(id).orElse(null);
    return LCAService.calculate(product);
  }
}